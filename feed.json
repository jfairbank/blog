
processFeed({
  "posts": [
    
      
        {
          "title": "Functional JavaScript Part 2: Streams",
          "content": "\n  \n    Contents\n  \n\n\n  Streams\n  Creating Streams with Generators\n  Creating the Stream Data Structure\n  The take Function\n  Creating Other Streams\n  Mapping Over Streams\n  Filtering Streams\n  Conclusion\n\n\n  \n\n\n\nThis post picks up from a series on functional programming I started a few\nmonths ago. In\nthe last post, I explained\nrecursion and immutability through constructing the list data structure. In this\npost, we will examine another concept in functional programming: streams.\n\nStreams\n\nSo, what are streams? I am sure you have probably heard of streams in JavaScript\nand Node before, and streams in functional\nprogramming are similar. One important use case for streams in functional\nprogramming is to represent infinite data sequences such as the natural numbers.\n\nBut what is so special about streams? Well, just like streams in Node, we can\nwork with data in small chunks, avoiding exhausting memory. Imagine trying to\nrepresent all the natural numbers in memory! When I say that we work in “small\nchunks,” I mean that we delay getting values in a stream until necessary. This\nis called lazy evaluation.\n\nWith a stream of natural numbers, that means I would start the stream with the\nvalue 1. I would have to consume the stream again to get the next value of\n2. Repeating this process would yield 3, 4, and so on.\n\nCreating Streams with Generators\n\nIf you have kept up with ES2015, this concept might sound familiar. Generator\nfunctions afford us the power of streams in JavaScript. So how would we create a\nstream of the natural numbers with generators?\n\nnatural-numbers-generator-imperative.jslinkfunction *naturalNumbers() &#x7b;\n  let n = 1;\n   while (true) &#x7b;\n    yield n++;\n  &#x7d;\n&#x7d;\n const nats = naturalNumbers();\n console.log(nats.next().value) // 1\nconsole.log(nats.next().value) // 2\nconsole.log(nats.next().value) // 3\n\nThis is a pretty straightforward implementation. We keep track of the current\nnumber in the sequence with n. We set n = 1 because naturally (pun intended)\nthe natural numbers start with 1. Then, inside an infinite loop, we yield n\nand increment it to the next number in the sequence.\n\nHowever, this implementation is not very functional. We use mutation by\nreassigning values to n. We could alter the implementation to use recursion:\n\nnatural-numbers-generator-recursive.jslinkfunction *naturalNumbers() &#x7b;\n  function *_naturalNumbers(n) &#x7b;\n    yield n;\n    yield *_naturalNumbers(n + 1);\n  &#x7d;\n   yield *_naturalNumbers(1);\n&#x7d;\n const nats = naturalNumbers();\n console.log(nats.next().value) // 1\nconsole.log(nats.next().value) // 2\nconsole.log(nats.next().value) // 3\n\nNow we create a generator function that uses an internal generator function\ncalled _naturalNumbers. It takes n as a parameter with an initial value of\n1. Inside our internal function, we yield n and then recursively yield a\ncall to the same function with n + 1. Notice the use of yield *. This\nspecial syntax allows us to delegate a yielded value to another generator\nfunction. If we had just used yield, we would have yielded a new instance of\nthe generator instead of the next number in the sequence.\n\nThere is still a problem with this implementation, though. Notice how we consume\nour values with nats.next().value. That generator has to maintain state\ninternally for it to be able to yield each value in the sequence. That means\nsome mutation is taking place. If we want to be super strict about immutability\nwith functional programming, then we need to roll our own stream data structure.\n\nCreating the Stream Data Structure\n\nHow do we accomplish creating a stream data structure? Remember that streams are\nlazy structures. We evaluate the first value but delay evaluating the remaining\nvalues. That sounds like we need some type of callback to represent the\nremaining values.\n\nHey! This is starting to sound like a list too. So, we need to create some type\nof data structure with a head and a tail, where the tail is evaluated at a later\npoint in time. An implementation could look something like this then:\n\nnatural-numbers-functional-stream-1.jslinkfunction naturalNumbers() &#x7b;\n  function _stream(n) &#x7b;\n    return &#x7b;\n      value: n,\n      next() &#x7b;\n        return _stream(n + 1);\n      &#x7d;\n    &#x7d;;\n  &#x7d;\n   return () =&gt; _stream(1);\n&#x7d;\n const nats = naturalNumbers();\nconst one = nats();\nconst two = one.next();\nconst three = two.next();\n console.log(one.value);\nconsole.log(two.value);\nconsole.log(three.value);\n\nNow this is definitely more functional. We remove mutation and depend on\nrecursive calls of an internal function to generate the values in our stream.\nLet’s walk through this implementation.\n\nI mentioned we use recursive calls to an internal function. We create the\ninternal function _stream that takes in our n parameter. It returns a\nlist-like data structure. The head is the value property which contains the\nvalue of n. The tail is a function called next that returns a recursive call\nto _stream with n + 1 as an argument. This is similar to the recursive\ngenerator implementation we had earlier. Finally to kick it all off, we return a\nclosure that calls _stream with our initial value of 1.\n\nNow one thing that is slightly irritating is the way we have to consume values.\nWe consecutively have to call the initial stream or the next function. What we\nneed is some helper function that can grab multiple values from the stream and\nreturn them.\n\nThe take Function\n\nTo help us solve the problem of consuming multiple values from a stream, we can\ncreate the take function. take is a function that takes a number n and a\nstream str and returns the first n values of str. An implementation of\ntake would look like:\n\ntake.jslinkfunction take(n, str) &#x7b;\n  function _take(n, str, accum) &#x7b;\n    if (n === 0) &#x7b;\n      return accum;\n    &#x7d;\n     const &#x7b; value, next &#x7d; = str();\n     return _take(n - 1, next, accum.concat(value));\n  &#x7d;\n   return _take(n, str, []);\n&#x7d;\n\nAgain, we use an internal function to help us. (We could use an optional\nparameter with the outer function instead, but that might not be considered\nstrictly functional.) The internal function _take takes the same argument\ntypes as the outer function take, n and str, as well as another argument\naccum. accum is short for accumulator, and it will be an array that holds\nthe values we have consumed from the stream.\n\nWe use recursion with _take to obtain our stream values. We grab the current\nvalue and the next function from the current stream at line 7. Then we make\nthe recursive call at line 9. Notice we pass in n - 1 and the next function as\nour new stream. We also concatenate the current value to the accum array,\nproducing a new array that we pass in as the new accumulator.\n\nRemember that we decrement n with n - 1 in our recursive call. This is\nimportant because it will lead to our base case when n === 0. At that point,\nwe no longer want to consume values from the stream, so we return whatever is in\naccum.\n\nThis implementation is not without its faults because it will have a quadratic\nruntime thanks to our calls to accum.concat. We could fix that with mutation\nvia array.push or using a list like the one in my last functional programming\npost, but we won’t worry about that\nhere.\n\nSo, let’s use our new take function to get the first ten natural numbers:\n\nnatural-numbers-take.jslinkconst nats = naturalNumbers();\nconst firstTen = take(10, nats);\n console.log(firstTen);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nGreat! This is not only simpler, but a more declarative way of consuming values\nfrom a stream.\n\nCreating Other Streams\n\nNow we could apply our new stream technique to create other infinite sequences.\nWhat if we wanted to create a stream of the Fibonacci sequence? Remember the\nFibonacci sequence is a sequence of numbers where every number is the sum of the\nprevious two numbers in the sequence. We also need two base case numbers, 0 and 1.\nTherefore, the sequence would be 0, 1, 1, 2, 3, 5, 8, etc. Implementing this as\na stream could look something like this:\n\nfibonacci-sequence-stream-1.jslinkfunction fibonacciSequence() &#x7b;\n  function _stream(current, next) &#x7b;\n    return &#x7b;\n      value: current,\n      next() &#x7b;\n        return _stream(next, current + next);\n      &#x7d;\n    &#x7d;;\n  &#x7d;\n   return () =&gt; _stream(0, 1);\n&#x7d;\n const fibs = fibonacciSequence();\nconst firstTen = take(10, fibs);\n console.log(firstTen);\n// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n\nNotice anything? Reapplying the stream technique to the Fibonacci sequence seems\nduplicative. What we really need is a more DRY approach to creating streams.\nTherefore, we need to abstract the construction of the stream data structure\ninto a reusable function. Then, we can build streams with just a function call:\n\nstream.jslinkfunction stream(fn, initial) &#x7b;\n  function _stream(value) &#x7b;\n    return &#x7b;\n      value,\n      next() &#x7b;\n        return _stream(fn(value));\n      &#x7d;\n    &#x7d;;\n  &#x7d;\n   return () =&gt; _stream(initial);\n&#x7d;\n\nThis implementation closely models what we already did with the natural numbers\nand the Fibonacci sequence. We create an internal _stream function that takes\nsome value and then returns an object literal that wraps that value and a\nclosure that produces the next value. Notice in the next function when we make\nour recursive call that we also call the fn argument that was supplied to\nstream. This is the function that is responsible for actually generating the\nnext value. In the case of the natural numbers, it would be a function that adds\n1 to its argument.\n\nNow we can convert our two streams to use our new stream function:\n\nstream-usage.jslinkconst nats = stream(n =&gt; n + 1, 1);\nconst fibs = stream(([current, next]) =&gt; [next, current + next], [0, 1]);\n console.log(take(10, nats));\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n console.log(take(10, fibs));\n// [0, 1, 1, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 13, 13, 21, 21, 34, 34, 55]\n\nWith our new stream function, all we have to do is provide a recurrence\nfunction and an initial value. Whatever is returned from the recurrence function\nis used as the next value in the stream and is also the next argument to the\nrecurrence function (recurrence inception, I know). For the natural numbers,\nthat recurrence is simply adding 1 to the last number: n + 1.\n\nBut wait a minute! What is going on with the Fibonacci sequence? Our recurrence\nfunction takes in an array and returns an array. Also, the output from\nconsole.log(take(10, fibs)) seems to be duplicating numbers. Recall that our\nstream uses the return value from the recurrence function as the next argument\nfor the recurrence function. Also, recall that the Fibonacci sequence is defined\nas the sequence of numbers where each number is the sum of the previous two\nnumbers. Therefore, we must use an array to keep track of the previous two\nnumbers. That presents a problem when we actually consume numbers in the\nFibonacci sequence. We only want the first element in each array returned from\nthe recurrence function. What we need is some way to map over streams.\n\nMapping Over Streams\n\nIf streams are like lazy lists, then surely we can map over them\nlike lists. However, we need to ensure\nthat a map function for streams does not consume the stream. That defeats the\npurpose of the stream — not to mention that that would cause an infinite\nloop.\n\nThus, map must produce a new stream itself. Then, when we consume the mapped\nstream, we will get back the modified values of the original stream. We can\nimplement map like so:\n\nmap.jslinkfunction map(fn, originalStr) &#x7b;\n  function _stream(str) &#x7b;\n    const &#x7b; value, next &#x7d; = str();\n     return &#x7b;\n      value: fn(value),\n      next() &#x7b;\n        return _stream(next);\n      &#x7d;\n    &#x7d;;\n  &#x7d;\n   return () =&gt; _stream(originalStr);\n&#x7d;\n\nEssentially, what we do in map is reimplement our stream pattern from the\nstream function. Our initial value will be the stream over which we want to\nmap. We also use an internal helper function called _stream that actually\nproduces the stream data structure.\n\nWhen we return our stream data structure, we call the mapping function fn on the\nrecently consumed value from the original stream to produce the new value\nproperty. With this implementation, we can lazily consume and transform the\nvalues from the original stream. Now, we can fix our Fibonacci sequence along\nwith the aid of a helper function called first:\n\nfibonacci-mapped.jslinkfunction first(array) &#x7b;\n  return array[0];\n&#x7d;\n const fibs = map(first, stream(([current, next]) =&gt; [next, current + next], [0, 1]));\n console.log(take(10, fibs));\n// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n\nAwesome! That fixes our issue and feels very functional, at least in the sense\nof composing functions to produce our stream. We could even use map to create\nthe sequence of even numbers from our sequence of natural numbers:\n\neven-numbers-sequence.jslinkconst nats = stream(n =&gt; n + 1, 1);\nconst evenNumbers = map(n =&gt; n * 2, nats);\n console.log(take(10, evenNumbers));\n// [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nFiltering Streams\n\nSo, we can map over our streams, but what if we wanted to filter values? For\nexample, with filtering we could create the sequence of odd numbers from our\nnatural numbers, or we could filter out numbers that are less than 42.\nUnsurprisingly, we can write a filter function that is similar to our map\nfunction:\n\nfilter.jslinkfunction filter(fn, originalStr) &#x7b;\n  function _stream(str) &#x7b;\n    const &#x7b; value, next &#x7d; = str();\n     if (fn(value)) &#x7b;\n      return &#x7b;\n        value,\n        next() &#x7b;\n          return _stream(next);\n        &#x7d;\n      &#x7d;;\n    &#x7d;\n     return _stream(next);\n  &#x7d;\n   return () =&gt; _stream(originalStr);\n&#x7d;\n\nfilter-usage.jslinkconst nats = stream(n =&gt; n + 1, 1);\nconst oddNumbers = filter(n =&gt; n % 2 !== 0, nats);\nconst gte42 = filter(n =&gt; n &gt;= 42, nats);\n console.log(take(10, oddNumbers));\n// [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n console.log(take(10, gte42));\n// [42, 43, 44, 45, 46, 47, 48, 49, 50, 51]\n\nfilter, like map, is very similar to the stream function. It uses the\noriginal stream as the initial value, and its internal function _stream\nfilters over the consumed values of the original stream. _stream accomplishes\nthis by consuming a value and then running the filter callback fn on it. If\nfn returns true, then _stream will essentially return what the original\nstream data structure would have returned except the new next function\nwill filter on the next function from the original stream. If fn returns\nfalse, then _stream will delegate its result by recursively calling itself\nwith the next function from the original stream.\n\nConclusion\n\nStreams are a powerful concept in JavaScript and functional programming. We can\nrepresent infinite sequences without consuming a ton of memory. We can also use\nthe concepts of composition to create new sequences from other sequences through\nlazy helper functions like map and filter. This notion of composition is\ncritical to functional programming and helps reinforce other concepts like\nmodularity and the single responsibility principle. Streams are an important\ntool in the bag of functional and JavaScript programmers.\n",
          "link": "http://blog.jeremyfairbank.com/javascript/functional-javascript-streams-2/",
          "date": "2015-08-07 00:00:00 -0400",
          "excerpt": ""
        }
        
      
    
      
        ,{
          "title": "JavaScript ES7 Function Bind Syntax",
          "content": "\n  \n    Contents\n  \n\n\n  The Syntax\n  Iteration\n  Callbacks\n  Chaining\n  Getting Started\n  Gripes, Caveats, Wishlist\n  Conclusion\n\n\n  \n\n\n\n\n  Bind your functions with this one weird trick!\n\n\nSorry, I couldn’t resist.\n\nI write this post with hesitation but excitement. I have enjoyed playing around\nwith the new ECMAScript function bind syntax as proposed\nhere. This is a very early\nproposal for addition in ES2016 (ES7, whatever) and could drastically change\nor even be scrapped. Therefore, I recognize that this post may become obsolete.\n\nI hope by advocating for this syntax, it will get the attention it deserves so\nthat it will become standard ES syntax. I find it to be a very versatile and\nwelcome tool in my JavaScript arsenal.\n\nThe Syntax\n\nSo what does the syntax actually look like?\n\nsyntax.jslink// Binding a function to a context\nlet log = ::console.log;\n // Calling functions with a context\nlet foo = &#x7b;&#x7d;;\n function bar() &#x7b;\n  log(this);\n&#x7d;\n function world(a) &#x7b;\n  log(this, a);\n&#x7d;\n foo::bar();\n function hello() &#x7b;\n  foo::world(...arguments);\n&#x7d;\n\nThat’s pretty much it. The proposal introduces a new :: operator that\nsimplifies function binding. Essentially, it offers syntactic sugar for calling\nthe bind, call, and apply methods on Function.prototype. The equivalent\nES5 code is below:\n\nsyntax-compiled.jslink// Binding a function to a context\nvar log = console.log.bind(console);\n // Calling functions with a context\nvar foo = &#x7b;&#x7d;;\n function bar() &#x7b;\n  log(this);\n&#x7d;\n function world(a) &#x7b;\n  log(this, a);\n&#x7d;\n bar.call(foo);\n function hello() &#x7b;\n  world.apply(foo, arguments);\n&#x7d;\n\nWe could call it a day at that, but I don’t want to devalue the power that this\nsyntax affords us. Let’s explore the ramifications of this syntax further.\n\nIteration\n\nHow often have you done something like this in your JavaScript code?\n\nes5-iteration.jslinkvar ArrayProto = Array.prototype;\nvar map = ArrayProto.map;\nvar filter = ArrayProto.filter;\nvar todoItems = document.querySelectorAll('ul.my-list &gt; li');\n var completedItems = filter.call(todoItems, function(item) &#x7b;\n  return item.dataset.completed;\n&#x7d;);\n var titles = map.call(todoItems, function(item) &#x7b;\n  return item.textContent;\n&#x7d;);\n\nGranted, you might be using a framework for your Todo app or a library like\nlodash for iteration, but I don’t doubt we’ve all used the native Array\nmethods on a different context at some point. It’s tedious and messy, but it gets\nthe job done.\n\nNow, with function bind syntax, we can make this code more expressive and\nelegant:\n\nes7-iteration.jslinklet &#x7b; map, filter &#x7d; = Array.prototype;\nlet todoItems = document.querySelectorAll('ul.my-list &gt; li');\n let completedItems = todoItems::filter(item =&gt; item.dataset.completed);\nlet titles = todoItems::map(item =&gt; item.textContent);\n\nThe semantics remain the same, yet this reads more naturally and hides away the\nuglier syntax we’re accustomed to.\n\nIf you visit the proposal\n(link), you’ll see another\nexample where we can import helper functions from a hypothetical iteration\nlibrary to iterate over a collection. This creates a better separation of\nconcerns between data structures and function calls on those structures through\ngeneralization.\n\nMaybe your data structure needs to provide only one function for iteration, and\nthen you can import iteration “methods” that depend on the function. This\ncreates modularization possibilities in our JavaScript code similar to Ruby’s\nEnumerable module (link).\n\nCallbacks\n\nAnother common pattern in JavaScript is passing callbacks to another function\nlike an event library. This becomes tricky when we desire a specific this\ncontext for our callback. Normally, we have to create a reference to this in a\nseparate variable and refer to it in our callback, or we call\nFunction.prototype.bind on our callback, passing in this.\n\nes5-callbacks.jslinkvar eventLib = require('eventLib');\nvar self = this;\n eventLib.on('foo', function() &#x7b;\n  self.gotFoo();\n&#x7d;);\n eventLib.on('bar', this.gotBar.bind(this));\neventLib.on('log', console.log.bind(console));\n\nAgain, this is a little messy and slightly ugly. But with function bind syntax,\nit becomes drastically simpler:\n\nes7-callbacks.jslinkimport eventLib from 'eventLib';\n eventLib.on('foo', ::this.gotFoo);\neventLib.on('bar', ::this.gotBar);\neventLib.on('log', ::console.log);\n\nThis is powerfully expressive. No function wrapping. No explicit bind calls\n(we’re obviously still calling it via ::, but we hide away those details). We\nare declaring our intent that these functions should be called in response to an\nevent, and we’re ensuring our this context with minimal effort.\n\nChaining\n\nIf I wasn’t already convinced by the function bind syntax, chaining is what\nreally sold it for me. Recently, I have been using\nPhantomCSS and\nCasperJS for a CSS refactoring endeavor. Of course, I’m\non the up-and-up and utilizing ES2015 via Babel to write\nmy test suite. If you have not heard of PhantomCSS or CasperJS, I encourage you\nto check them out. PhantomCSS is a very promising project for automating visual\nregressions of your website. CasperJS is a wrapper over PhantomJS and SlimerJS,\noffering a higher-level API.\n\nFor this particular project, I represent web pages as classes according to a\nminimal interface. They each have a run method that takes in my casper\ninstance. From there, each class chains method calls on my casper instance,\nreturning the result. It’s very “promisey.” (I also added a few custom methods\nto my instance to wrap over some other methods to make them more “promisey.”)\n\nTo avoid duplication in some classes, I wanted to add some methods to the\ncasper instance that are specific to the concerns of that page. However, I\ndidn’t want to pollute the actual object instance. Function bind syntax to the\nrescue!\n\nes7-casper-chaining.jslinkclass HomePage &#x7b;\n  run(casper) &#x7b;\n    function thenClickInMySection(n, selector) &#x7b;\n      return this.thenClick(`.my-section:nth-of-type($&#x7b;n&#x7d;) $&#x7b;selector&#x7d;`);\n    &#x7d;\n     function thenScreenshotContainer(name) &#x7b;\n      return this.thenScreenshot('#container', name);\n    &#x7d;\n     return casper\n      .thenVisit('http://my-url.com/home')\n      .thenScreenshot('body', 'home')\n      ::thenClickInMySection(1, '.foo')\n      ::thenScreenshotContainer('foo')\n      .thenClick('.cancel')\n      ::thenClickInMySection(2, '.bar')\n      ::thenScreenshotContainer('bar');\n  &#x7d;\n&#x7d;\n\nThat is amazing! I can naturally express the chaining semantics while decorating\nmy instance without altering it. Just as a reminder of what we would probably\nhave to do without function bind syntax, here is some equivalent ES2015 code:\n\nes6-casper-chaining.jslinkclass HomePage &#x7b;\n  run(casper) &#x7b;\n    function clickInMySection(n, selector) &#x7b;\n      return casper.thenClick(`.my-section:nth-of-type($&#x7b;n&#x7d;) $&#x7b;selector&#x7d;`);\n    &#x7d;\n     function screenshotContainer(name) &#x7b;\n      return casper.thenScreenshot('#container', name);\n    &#x7d;\n     casper = casper\n      .thenVisit('http://my-url.com/home')\n      .thenScreenshot('body', 'home');\n     casper = thenClickInMySection(1, '.foo');\n    casper = thenScreenshotContainer('foo');\n    casper = casper.thenClick('.cancel');\n    casper = thenClickInMySection(2, '.bar');\n    casper = thenScreenshotContainer('bar');\n     return casper;\n  &#x7d;\n&#x7d;\n\nIt gets the job done, but it doesn’t flow as nicely as our chaining example.\nFunction bind syntax allows us to reduce how much code we write and effectively\nexpress this notion of flowing through each step.\n\nGetting Started\n\nIf you’d like to try out function bind syntax, then I encourage you check it out\nwith Babel. If you’ve not heard of Babel, it’s a transpiler that transforms\nES2015/2016 code into ES5. You can learn more about Babel from its website\n(link) and learn how to use function bind syntax\nhere.\n\nGripes, Caveats, Wishlist\n\nI don’t think this syntax is without its faults. I’m not entirely sold on the\nactual :: operator yet. Maybe it’s the baggage I carry from other languages\nlike Ruby, PHP, and CoffeeScript, each which use that operator for different\nsemantics. Another option might be the -&gt; operator, but it’s not my favorite\neither (burnout from PHP and C, no doubt). The :: operator might be the best\nsolution, and I don’t necessarily hate it.\n\nI haven’t dived into the discussion over this spec, but to my knowledge there is\nno affordance for partial application via this syntax. Recall that the bind\nmethod on Function.prototype can also partially apply parameters to the bound\nfunction by passing in additional arguments.\n\nes5-partial-application.jslinkvar DEBUG = console.log.bind(console, 'DEBUG:');\n function add(x, y) &#x7b;\n  return x + y;\n&#x7d;\n var add1 = add.bind(null, 1);\nvar three = add1(2);\n DEBUG(three); // prints \"DEBUG: 3\"\n\nI would like to see some type of partial application syntax, especially as we\ncontinue to push the boundaries of functional-style programming in JavaScript.\nAlas, I recognize that designing clean, efficient syntax is difficult. This may\njust not be possible. Some quick ideas for a syntax could be:\n\nes7-partial-application.jslinkconst DEBUG1 = ::console.log('DEBUG:');\n// Currently calls the function back on the same receiver\n// var DEBUG1 = console.log.call(console, 'DEBUG:');\n const DEBUG2 = ::console.log['DEBUG:'];\n// This clashes with existing [] semantics\n// var DEBUG2 = console.log['DEBUG:'].bind(console);\n const DEBUG3 = ::console.log&lt;'DEBUG:'&gt;;\n// SyntaxError\n const DEBUG4 = ::console.log&#x7b;'DEBUG:'&#x7d;;\n// SyntaxError\n function add(x, y) &#x7b;\n  return x + y;\n&#x7d;\n let add1 = ::add(1);\n// SyntaxError (we need a context for the bind operator)\n // ...\n\nConclusion\n\nDespite my small gripes and wishes, I readily welcome this proposal for ES2016\nand hope the maintainers strongly consider its inclusion. This syntax opens up\nthe door for writing cleaner and more expressive JavaScript.\n",
          "link": "http://blog.jeremyfairbank.com/javascript/javascript-es7-function-bind-syntax/",
          "date": "2015-05-30 00:00:00 -0400",
          "excerpt": ""
        }
        
      
    
      
        ,{
          "title": "Functional JavaScript Part 1: Lists",
          "content": "\n  \n    Contents\n  \n\n\n  Recursion and Immutability\n  The List\n  Implementing the List\n  Implementing Map and Reduce    \n      Map\n      Reduce\n    \n  \n  Wrapping It Up\n\n\n  \n\n\n\nFunctional programming may seem like a buzzword or fad, but there are good reasons why\nso many companies and frameworks are hopping on board these days, *cough*\nFacebook *cough*. Functional programming has been around for a long time now\nactually and shows no signs of stopping. It is simply elegant at times, naturally\nexpressing problems and their solutions in terms of what instead of how.\n\nThankfully, JavaScript is already capable of equipping programmers with powerful\nfunctional programming constructs. So, I would like to take some time to go\nthrough a short post series on functional programming (FP). In this first post,\nI will go over the classic case study of the power of FP, the list. We will\ndiscover the beauty of building and iterating lists through two keystone\nFP concepts, recursion and immutability.\n\nRecursion and Immutability\n\nIn case you are unfamiliar with recursion and immutability, we will expound\nupon them for a minute.\n\nAccording to Wikipedia:\n“Recursion is the process of repeating items in a self-similar way.”\n\nIn terms of FP, this is the action of a function calling itself a number of times.\nOK… but what does that accomplish? Well, one classic example is implementing\na function to calculate the value of the Fibonacci sequence at a given number n:\n\nfib.jslinkfunction fib(n) &#x7b;\n  if (n &lt; 2) &#x7b;\n    return n;\n  &#x7d;\n   return fib(n - 1) + fib(n - 2);\n&#x7d;\n\nNotice that we call our fib function inside itself for inputs n &gt; 1. We return\nthe result of fib(n - 1) + fib(n - 2) to get the final answer. If we were to\ntrace calls to fib for n = 4, we would see something like this:\n\nfib-calls.jslinkfib(4)\nfib(3) + fib(2)\nfib(2) + fib(1) + fib(1) + fib(0)\nfib(1) + fib(0) + 1 + 1 + 0\n1 + 0 + 1 + 1 + 0\n3\n\nNotice something interesting? At the next to last line, all that is left is addition\nwith 1's and 0's to yield 3. This is the power of recursion, the base case.\n\nThink of recursion in terms of a tree. At the root of our tree is the base case(s).\nFor fib, our base cases are 1 and 0, so they comprise the root of the tree.\nFrom the root, the tree grows out into branches and leaves. Those leaves are\nour values for n &gt; 1. We cannot have the leaves without the root, so we cannot\nhave these answers without our base cases.\n\nImagine if we wanted to traverse the life source of that leaf. We would start at\nthe leaf, working our way down the branches and trunk step-by-step to finally\narrive at the root. That is like our growing call stack with recursive calls to\nfinally get to something that returns an actual value, 1 or 0. Then,\neverything cascades back up to give us our final value, which is 3 in the case\nof n = 4.\n\nNow compare this to an imperative approach with dynamic programming:\n\nfib-imperative.jslinkfunction fib(n) &#x7b;\n  if (n &lt; 2) &#x7b;\n    return n;\n  &#x7d;\n   var n0 = 0;\n  var n1 = 1;\n  var ans = 0;\n   for (var i = 2; i &lt;= n; i++) &#x7b;\n    ans = n0 + n1;\n    n0 = n1;\n    n1 = ans;\n  &#x7d;\n   return ans;\n&#x7d;\n\nThat is a little less understandable, albeit FAAAARRR more performant. If we\ncompare the imperative approach with the functional approach, we find that the\nfunctional approach more naturally expresses the recurrence relation of the Fibonacci \nsequence, , where  and .\nThe recurrence relation is in the imperative approach too, but we have to look\na little harder.\n\nThat briefly covers recursion, but what about immutability? Let us compare the\ntwo implementations of our fib function again. You will notice that our imperative\napproach modifies the value of several variables multiple times. We increment\ni and reassign values to ans, n0, and n1. Our functional approach\nnever reassigns values to anything. In fact, the only variable in our functional\nimplementation is our one n parameter, and we never change it.\n\nWhen we do not change the values of our state (i.e. our variables), we are enforcing\nimmutability. The converse, mutability, is when we mutate state (i.e. change the value of\nvariables). Immutability is a key tenet of FP. It allows us to think of our functions\nin simpler terms: single input, single output, no side effects. This can help us produce\nfewer bugs (take that with a grain of salt) and make testing easier.\n\nThe List\n\nWith that introduction to recursion and immutability behind us, we can now focus\non our task of building the functional list.\n\nSo, what is a list? I am sure most of you are already familiar with the concept\nof linked lists, and this is not very different. We will have a head, the first\nitem in a list, and a tail, the remaining items in the list. Typically, we use\nsome data structure that wraps the actual value and has a pointer or reference\nto the next item in the list. We know we are at the end of the list when the last\nitem points to some null reference.\n\nImagine we have a linked list of integers.  We would typically view it like so:\n\n\n\nFunctional lists are pretty much the same thing, but we adopt some different\nconventions when referring to them. Typically, we refer to our wrapping data structure\nas a “cons cell”. There are built-in operators and functions in functional\nlanguages to build a cons cell. The cons operation takes two arguments, a head\nand a tail. The head is the actual underlying value and the tail is the reference\nto the next cons cell.\n\nThe final item in the list will have a tail that points to nil, or the empty list.\nThis is the null value at the end of the linked list. It is that final nil reference\nthat really makes the top level cons cell a “list.”\n\nNow, when it comes to functional lists, I like to picture them differently. I like\nto view each item’s tail as a literal tail of the remaining items instead of just\na reference to the next item. I like to imagine a recursive (there is\nthat word again) data structure of cons cells wrapping other cons cells until we\nget to the final empty list. Treating this as a recursive data structure is\nhugely powerful! Just look below; you may even see why that tree analogy is so\nimportant.\n\n\n\nWhen we think back to our tree analogy, this illustration suggests something\npowerful about lists as recursive data structures. Notice the similarities\nwith our Fibonacci function call stack. We now think of our list in terms of what\nit is built up from: the empty list.\n\nWith this revelation, we can begin to implement functions to operate on our list.\nWe will look at two classic functions, map and reduce, and create our own recursive\nimplementations of them for our list.\n\nImplementing the List\n\nFirst, we need to create our list data structure. To accomplish this, we actually\nneed to implement the cons cell and nil, the empty list.\n\ncons-1.jslinkvar Cons = function(head, tail) &#x7b;\n  this.head = head;\n  this.tail = tail;\n&#x7d;;\n Cons.prototype.isEmpty = false;\n\nnil-1.jslinkvar Nil = &#x7b;\n  isEmpty: true,\n   get head() &#x7b;\n    throw new Error('Accessing head on empty list.');\n  &#x7d;,\n   get tail() &#x7b;\n    throw new Error('Accessing tail on empty list.');\n  &#x7d;\n&#x7d;;\n\nSo, Cons has a head property, a tail property, and isEmpty = false.\nNotice that Nil is an object literal instead of a constructor function. It\ndoes not make sense to make multiple instances of Nil when it always represents\nthe empty list. This is no different than the null value in programming languages.\nAlso notice that since Nil is the empty list, isEmpty = true, and we throw\nerrors if you try to access head or tail on it.\n\nSo, if we wanted to build a list, we could do this then:\n\nbuild-list-1.jslinkvar list = new Cons(1, new Cons(3, new Cons(42, new Cons(28, Nil))));\n\nThat is unsightly, though. We should at least introduce a helper function to\nclean it up a little:\n\nbuild-list-2.jslinkvar cons = function(head, tail) &#x7b;\n  return new Cons(head, tail);\n&#x7d;;\n var list = cons(1, cons(3, cons(42, cons(28, Nil))));\n\nThat is better; we will create an even nicer-looking function later on, but we will\nuse this for now.\n\nImplementing Map and Reduce\n\nNow we are ready to create our own implementations of map and reduce. If you\nare unfamiliar with these functions, I encourage you to check out the examples at\nthe Mozilla developer website for JavaScript arrays:\nmap\nand\nreduce.\n\nBriefly, map takes a list, applies some transformation function to each item,\nand returns a new list of those transformed items. reduce takes a list and\ntransforms the list (reduces the list) to some other value by applying the\ntransformation function to each item in the list.\n\nWe will implement these functions in two manners, first as regular functions and\nthen as methods of our Cons and Nil objects. First, let us look at map.\n\nMap\n\nmap.jslinkvar map = function(list, fn) &#x7b;\n  if (list.isEmpty) &#x7b;\n    return list;\n  &#x7d;\n   return cons(fn(list.head), map(list.tail, fn));\n&#x7d;;\n\nSo what is going on here? Just like our functional fib implementation and with\nalmost any FP function, we need a base case. Remember that this is the root from\nwhich we build our result. In this instance, our base case is Nil. We check\nthat via the isEmpty property. If it is true, then we just return list\n(we could return Nil here too since they are the same object).\n\nNow let us dissect the meat of this function at line 6. This is a map function,\nso we have to apply the supplied function argument fn to each value. We do that\nby calling fn(list.head). Because we need to apply the function to every item,\nwe then recursively call map with the remaining items, which are referenced by\nlist.tail. Therefore, we call map(list.tail, fn). Finally, we wrap those two\ncalls in cons, returning cons(fn(list.head), map(list.tail, fn)). Notice\nanything else? We are returning a new cons cell. We never modified our original list,\nso we are upholding immutability too.\n\nIf we follow the recursive calls, we will see our call stack keep growing until\nwe finally get to Nil. Once we return it, we can begin to return the result\nfor each remaining frame in the stack until the first call returns the new list.\nHere is how the list will get built with each call below:\n\nmap-call-1.jslinkvar list = cons(1, cons(2, cons(3, Nil)));\nvar double = (n) =&gt; n * 2;\n map(list, double); // yields:\n cons(2, map(cons(2, cons(3, Nil)), double));\ncons(2, cons(4, map(cons(3, Nil), double)));\ncons(2, cons(4, cons(6, map(Nil, double))));\ncons(2, cons(4, cons(6, Nil)));\n\nThere is our first implementation of map. But what if we wanted to utilize JavaScript’s\nobject-oriented capabilities and eliminate that isEmpty conditional check? In\nthis case we need to add map as a method to the Cons prototype and to\nthe Nil object.\n\noop-map.jslinkCons.prototype.map = function(fn) &#x7b;\n  return cons(fn(this.head), this.tail.map(fn));\n&#x7d;;\n Nil.map = function() &#x7b;\n  return this;\n&#x7d;;\n\nBasically what we have done is separate out the branches of computation in map\nto the objects with which they are concerned. Cons#map builds up the new cons cells\nand Nil just returns itself. Notice we also changed map(this.tail, fn) to\nthis.tail.map(fn). I think this looks a little nicer than the strict function\nimplementation. In most functional programming languages, we do not have this\naffordance, so they utilize some rather elegant pattern matching control structures\nthat are similar to switch statements but vastly more powerful.\n\nOur usage would only change in how we initially call map:\n\nmap-call-2.jslinkvar list = cons(1, cons(2, cons(3, Nil)));\nvar double = (n) =&gt; n * 2;\n list.map(double); // cons(2, cons(4, cons(6, Nil)))\n\nSo that is map. See how elegantly and simply we were able to implement it in just\na couple lines. An imperative approach would require some looping construct\nand constantly reassigning values to create a new list, which means more code\nthat may be harder to reason about (some people may find looping more\nintuitive, so I do not want to discredit them).\n\nReduce\n\nNext up is reduce. Recall that with reduce we want to transform our list into\nsome other value and that may not be another list. Here is the function\nimplementation:\n\nreduce.jslinkvar reduce = function(list, fn, memo) &#x7b;\n  if (list.isEmpty) &#x7b;\n    return memo;\n  &#x7d;\n   return reduce(list.tail, fn, fn(memo, list.head));\n&#x7d;;\n\nThis is very similar to our map implementation. Notice that we have one more\ninput this time, memo. Think of this as an accumulator, so we can keep track\nof the value that we are building from our list. Also notice that memo will\nserve as the value for our base case, the empty list. This is where we check\nisEmpty again.\n\nIf our list is not empty, then we of course make a recursive call to reduce,\npassing in the tail, the same transformation function fn, and the recalculated\nmemo value fn(memo, list.head). The combination of recursive calls and calculating\nnew memo values is what allows us to transform the entire list into something\nelse.\n\nHere is a great example where we can calculate the sum of a list of numbers:\n\nreduce-call-1.jslinkvar list = cons(1, cons(2, cons(3, Nil)));\nvar add = (x, y) =&gt; x + y;\n reduce(list, add, 0); //=&gt; 6\n\nAnd of course, let us simplify our implementation with the object-oriented\napproach:\n\noop-reduce.jslinkCons.prototype.reduce = function(fn, memo) &#x7b;\n  return this.tail.reduce(fn, fn(memo, this.head));\n&#x7d;;\n Nil.reduce = function(fn, memo) &#x7b;\n  return memo;\n&#x7d;;\n\nIf you are familiar with reduce, then you also know we could alter our\nimplementation to not require the initial memo argument. Instead we could make\nit optional, and use the first head as the initial memo if none is supplied.\n\nNow you might notice something. Is not map just a special case of reduce?\nYes! In fact we can implement map in terms of reduce's cousin reduceRight.\nreduceRight is just like reduce except it reduces the list items in the\nreverse direction. So, it would first encounter Nil, then the next-to-last\nitem, and keep going until it reaches the first item in the list. reduceRight\ncan be implemented as follows:\n\noop-reduceRight.jslinkCons.prototype.reduceRight = function(fn, memo) &#x7b;\n  return fn(this.tail.reduceRight(fn, memo), this.head);\n&#x7d;;\n Nil.reduceRight = Nil.reduce;\n\nThis is very close to the implementation of reduce except we flip the order in\nwhich we call our transformation function and when we make our recursive calls.\nThis ensures that the transformation function first gets called with Nil. This\nis crucial if we want to implement map in terms of reduceRight. If we used\nreduce instead, we would indeed map over our values, but build our new list in\nthe reverse direction.\n\nOur new map implementation can be seen below:\n\noop-map-reduce.jslinkCons.prototype.map = function (fn) &#x7b;\n  var consBuilder = function(memo, value) &#x7b;\n    return cons(fn(value), memo);\n  &#x7d;;\n   return this.reduceRight(consBuilder, Nil);\n&#x7d;;\n\nSince we are reducing from the right, we will start from Nil and build cons\ncells up from that. Think back to our list picture where we stacked the cons cells\nlike a tree. Picture reduceRight and our new map implementation as stacking\nthose cons cells from the bottom up.\n\nWrapping It Up\n\nI hope this gives you an idea of the power of expressiveness inherent in functional\nprogramming. With very little code, we built an iterable list and two\nfamous functions to operate on that list.\n\nHowever, please keep in mind that these are very basic implementations  and are\nnot optimized for performance. You will also run into issues if you try to iterate\nover very large lists. Because we depend on recursion, our call stack\ncould grow very large and lead to the infamous stack overflow. One way around\nthis is to utilize tail call optimization, a feature which is slated for ES6.\n(Essentially, if you tailor the last statement in your function correctly, you\ncan ensure that recursive calls do not add to the call stack but instead just\nreplace the current stack frame with a new one.)\n\nOne more thing. I mentioned there was a way we could simplify list construction\nto avoid several cons calls. We can implement a list function that takes\na variable number of arguments and produces a list. Since we are talking about\nFP, let us implement that function in a functional manner too.\n\nlist-constructor.jslinkvar list = function () &#x7b;\n  if (arguments.length === 0) &#x7b;\n    return Nil;\n  &#x7d;\n   var head = arguments[0];\n  var tail = [].slice.call(arguments, 1);\n   return cons(head, list.apply(null, tail));\n&#x7d;;\n\nSo notice here we are mirroring the concepts we used in our list functions. We\nare returning Nil if arguments are empty, so this is our base case. We then\nget the head and tail from arguments and pass them along to a cons call.\nInside that cons call we recursively apply the list function to the tail via\nlist.apply(null, tail).\n\nThen, we can use our list function for easier list construction:\n\nlist-calls.jslinkvar myList = list(1, 3, 5);\n//=&gt; cons(1, cons(3, cons(5, Nil)));\n var myOtherList = myList.map(n =&gt; n * 3);\n//=&gt; cons(3, cons(9, cons(15, Nil)));\n var nine = myList.reduce((x, y) =&gt; x + y);\n//=&gt; 9\n var listOfLists = list(list(1), list(2), list(3));\n//=&gt; cons(cons(1, Nil), cons(cons(2, Nil), cons(cons(3, Nil), Nil)));\n var flattened = listOfLists.map(innerList =&gt; innerList.head);\n//=&gt; cons(1, cons(2, cons(3, Nil)));\n\nThanks for reading and please leave any feedback or questions you may have on\nFP and lists. If you feel there are any holes in this explanation, please let me\nknow. I hope you now have a better understanding and appreciation for\nwhat is possible with functional programming. We will continue to investigate\nthe concepts of functional programming in future posts.\n",
          "link": "http://blog.jeremyfairbank.com/javascript/functional-javascript-lists-1/",
          "date": "2015-01-17 00:00:00 -0500",
          "excerpt": ""
        }
        
      
    
      
        ,{
          "title": "Polymer Web Components with Marionette.js",
          "content": "\n\n  \n    Contents\n  \n\n\n  Web Components and Polymer\n  Marionette.js Components\n  Building a Name Tag Element\n  Working with Marionette.js\n\n\n  \n\n\n\nJavaScript is a playground. If you disagree, then I encourage you to read\nAtwood’s Law.\nA quick Google search will reveal the law in full force with\nassemblers,\nmachine emulators, and\nprogramming languages\nall written in JavaScript. That is just a small sampling. Go peruse the\nnpm registry for plenty of build tools, frameworks, and\nservers written in JavaScript.  We are tinkerers, especially in the JavaScript community.\nSometimes our creations are practical and sometimes they are just fun.\n\nWith that introduction framing this post, I would like to show off some fun I had with Polymer\nand Marionette.js recently.\n\nWeb Components and Polymer\n\nBefore we dig in, here is a quick rundown of web components and Polymer if you are unsure\nwhat they are.\n\nWeb Components as a standard intends to empower web applications to be modular through\nnative browser technologies. Four specs comprise Web Components: Custom Elements, HTML\nImports, Templates, and the Shadow DOM. Essentially, web components allow developers to\ncreate reusable components with custom HTML elements. The Shadow DOM affords developers\nencapsulation of their custom elements via a separate DOM tree that does not bleed into\nthe containing document. For more information on Web Components, you can visit\nwebcomponents.org.\n\nDeveloped by Google, Polymer is a project that aims to simplify defining web components.\nTo the best of its ability, Polymer also polyfills any functionality not natively\navailable in the browser (e.g. custom elements, HTML imports, etc.). For more information\non Polymer, you can visit www.polymer-project.org.\n\nMarionette.js Components\n\nNow, back to the topic of this post. I first developed the idea of making Polymer components\nplay along with Marionette.js for a talk on architecture and components I gave at the inaugural\nNodevember conference in Nashville, TN.* If you would like to watch\nmy talk, you can view it on YouTube.\n\nToward the end of my talk, I demoed creating a custom name tag element. Furthermore, I showcased\nthe ability to wrap that custom element with a custom Marionette view type and keep model data\nsynced with a regular Marionette ItemView. I would like to go into more detail the steps\nI took to create this custom Marionette view type and how I was able to keep model data synced.\n\nBuilding a Name Tag Element\n\nOur name tag element will be pretty basic, displaying a name and job. We will also be able\nto edit the name and job. To build the name tag element, we will use this simple Polymer\nconvention for creating custom elements:\n\nname-tag-1.htmllink&lt;link rel=\"import\" href=\"../bower_components/polymer/polymer.html\"&gt;\n &lt;polymer-element name=\"name-tag\" attributes=\"name job\"&gt;\n  &lt;template&gt;\n    &lt;div&gt;Hello, my name is &#x7b;&#x7b;name&#x7d;&#x7d;&lt;/div&gt;\n    &lt;div&gt;My job is &#x7b;&#x7b;job&#x7d;&#x7d;&lt;/div&gt;&lt;br&gt;\n    &lt;div&gt;Name: &lt;input type=\"text\" value=\"&#x7b;&#x7b;name&#x7d;&#x7d;\"&gt;&lt;/div&gt;\n    &lt;div&gt;Job: &lt;input type=\"text\" value=\"&#x7b;&#x7b;job&#x7d;&#x7d;\"&gt;&lt;/div&gt;\n  &lt;/template&gt;\n  &lt;script&gt;\n    Polymer(&#x7b;\n      name: 'Joe Schmoe',\n      job: 'Plumber'\n    &#x7d;);\n  &lt;/script&gt;\n&lt;/polymer-element&gt;\n\nThere are few concepts to explain here. At line 1, we import our framework for defining\na custom element via an import link relation. At line 3, we define our custom element\nby wrapping it with a &lt;polymer-element&gt; tag. We define the name of our custom element\nvia the name attribute. Note that custom elements require at least one hyphen for\ntheir tag name. In other words, we cannot use &lt;nametag&gt;. We also publish attributes\nfor our custom element with the attributes… ahem, attribute. Publishing attributes\nwill allow us to set values for properties, which we will see in a second.\n\nAt lines 4-9, we define the template for our custom template by wrapping the template\ncontent with a &lt;template&gt; tag. Note the mustache-like syntax to interpolate values for\nname and job.\n\nFinally at lines 11-14, we tell Polymer about the properties of our custom element. Note,\nthey match the attributes we published, and we give them default values.\n\nNow we can use our custom element just like any other HTML element:\n\nname-tag-usage-1.htmllink&lt;!-- Load js lib --&gt;\n&lt;script src=\"bower_components/webcomponentsjs/webcomponents.min.js\"&gt;&lt;/script&gt;\n &lt;!-- Import name tag element --&gt;\n&lt;link rel=\"import\" href=\"name-tag-1.html\"&gt;\n &lt;!-- Default Usage --&gt;\n&lt;name-tag&gt;&lt;/name-tag&gt;\n &lt;!-- Supply Attributes --&gt;\n&lt;name-tag name=\"Jeremy\" job=\"Web Developer\"&gt;&lt;/name-tag&gt;\n\nDEMO\n\nWorking with Marionette.js\n\nLet us take this a step further and now integrate this with Marionette.js. If you are\nunfamiliar with Marionette, it is a framework that simplifies Backbone.js application\ndevelopment. You can learn more at marionettejs.com.\n\nWhat we want to accomplish is a way to not only instantiate our custom element with\nMarionette but to also sync model data with other Marionette views. We will tackle the\nformer first, allowing us to do this:\n\nname-tag-usage-marionette-1.jslinkvar NameTag = Marionette.PolymerView.extend(&#x7b;\n  tagName: 'name-tag'\n&#x7d;);\n // Assuming we have a DOM element with id 'main'\nvar mainRegion = new Marionette.Region(&#x7b;\n  el: '#main'\n&#x7d;);\n var person = new Backbone.Model(&#x7b;\n  name: 'Jeremy Fairbank',\n  job: 'Web Developer'\n&#x7d;);\n var nameTag = new NameTag(&#x7b;\n  model: person\n&#x7d;);\n mainRegion.show(nameTag);\n\nDEMO\n(Note: demo may not work on mobile devices.)\n\nAs you can see above, our custom Marionette view type is called Marionette.PolymerView.\nI have set up a basic GitHub repo for its implementation at\njfairbank/marionette.polymerview.\nYou can view the source in the below gist too:\n\nmarionette.polymerview.jslink/**\n * Copyright 2014 Jeremy Fairbank &lt;elpapapollo@gmail.com&gt;\n * License: https://github.com/jfairbank/marionette.polymerview/blob/master/LICENSE\n */\nMarionette.PolymerView = Marionette.View.extend(&#x7b;\n  constructor: function(options) &#x7b;\n    Marionette.View.prototype.constructor.apply(this, arguments);\n    this._setPublishedKeys();\n    this._initAttrsFromModel();\n    this._initModelEvents();\n    this._initPolymerEvents();\n  &#x7d;,\n   _setPublishedKeys: function() &#x7b;\n    this._publishedKeys = _.keys(this.el.publish);\n  &#x7d;,\n   _initAttrsFromModel: function() &#x7b;\n    this._setElAttrs(this.model.attributes);\n  &#x7d;,\n   _initModelEvents: function() &#x7b;\n    this.listenTo(this.model, 'change', this._updateElAttrsFromModel);\n  &#x7d;,\n   _initPolymerEvents: function() &#x7b;\n    if (!this.events) &#x7b;\n      this.events = &#x7b;&#x7d;;\n    &#x7d;\n     _.each(this._publishedKeys, function(key) &#x7b;\n      this.events['change:' + key] = _.bind(this._updateAttrFromEl, this, key);\n    &#x7d;, this);\n     this.delegateEvents();\n  &#x7d;,\n   _updateAttrFromEl: function(attributeName) &#x7b;\n    var value = this.el[attributeName];\n    this.model.set(attributeName, value);\n  &#x7d;,\n   _updateElAttrsFromModel: function() &#x7b;\n    this._setElAttrs(this.model.changed);\n  &#x7d;,\n   _setElAttrs: function(attributes) &#x7b;\n    var attributeNames = _.intersection(_.keys(attributes), this._publishedKeys);\n    _.each(attributeNames, this._setElAttr, this);\n  &#x7d;,\n   _setElAttr: function(attributeName) &#x7b;\n    this.el[attributeName] = this.model.get(attributeName);\n  &#x7d;\n&#x7d;);\n\nIt is not the most foolproof implementation, but it gets the job done and highlights how easily\nwe can work with a Polymer web component from Marionette. Instead of going line-by-line, I\nwill highlight the key things that `PolymerView` is doing.\n\nAt line 15, we grab the published attributes from the custom element via the `publish` property\non the custom element. Next, starting with the call to `this._initAttrsFromModel()` at line\n9, we set the value of any published attributes on our custom element from the passed-in\nBackbone model. At lines 10-11, we initialize events that will enable us to keep model data\nand web component data in sync. In other words, whether I update my model or a property in\nthe web component, the other will be updated with that information. We will go into more detail\nabout that below.\n\n## Syncing Data with Marionette.js\n\nThe final piece is to get data syncing to work. We can accomplish this by setting some property\nwatchers on our custom element. Unfortunately, I have not explored Polymer long enough\nto find a way around this. Therefore, you cannot grab web components defined by someone else\nand have data syncing with Marionette working out-of-the-box. Maybe a more general approach\nis possible; maybe you can help me figure it out!\n\nNonetheless, we will tweak our name tag definition to include some property watchers:\n\nname-tag-2.htmllink&lt;link rel=\"import\" href=\"../bower_components/polymer/polymer.html\"&gt;\n &lt;polymer-element name=\"name-tag\" attributes=\"name job\"&gt;\n  &lt;template&gt;\n    &lt;div&gt;Hello, my name is &#x7b;&#x7b;name&#x7d;&#x7d;&lt;/div&gt;\n    &lt;div&gt;My job is &#x7b;&#x7b;job&#x7d;&#x7d;&lt;/div&gt;&lt;br&gt;\n    &lt;div&gt;Name: &lt;input type=\"text\" value=\"&#x7b;&#x7b;name&#x7d;&#x7d;\"&gt;&lt;/div&gt;\n    &lt;div&gt;Job: &lt;input type=\"text\" value=\"&#x7b;&#x7b;job&#x7d;&#x7d;\"&gt;&lt;/div&gt;\n  &lt;/template&gt;\n  &lt;script&gt;\n    Polymer(&#x7b;\n      name: 'Joe Schmoe',\n      job: 'Plumber',\n       nameChanged: function() &#x7b;\n        this.fire('change:name');\n      &#x7d;,\n       jobChanged: function() &#x7b;\n        this.fire('change:job');\n      &#x7d;\n    &#x7d;);\n  &lt;/script&gt;\n&lt;/polymer-element&gt;\n\nAt lines 15 and 19, we define two functions `nameChanged` and `jobChanged`, respectively.\nThese are our property watchers. Notice the syntax is propertyChanged. Whenever\n`name` changes on our custom element (not the Backbone model!), `nameChanged` will be called.\nThis is automatically handled by Polymer. The same applies with `job` and `jobChanged`.\nNotice in each function's body, we call `this.fire` with a custom event name. This is the\npart that will allow us to notify Marionette about changes inside the custom element.\n\nOur Marionette `PolymerView` will detect these changes by Backbone's event delegation.\nBackbone's event delegation (via `delegateEvents`) is what is responsible for detecting\nDOM events in your Backbone views and responding to them with your own callback.\n\nmyView.jsvar MyView = Backbone.View.extend(&#x7b;\n  events: &#x7b;\n    'click button': 'doThatThang'\n  &#x7d;,\n   doThatThang: function() &#x7b;\n    console.log('hashtag yolo');\n  &#x7d;\n&#x7d;);\n\n\nWe capitalize on this functionality to respond to those custom `fire` events we defined.\nIf you look at lines 26-36 of the `PolymerView` source above, you will see where we utilize\n`delegateEvents` to listen for any attribute `fire` events. From there, we update our\nmodel data with the changes via the `_updateAttrFromEl` function.\n\nOn the flip side, at lines 22-24, we listen for any changes on our model, and call\n`_updateElAttrsFromModel` to update our custom element with those changes.\n\n## All Together Now\n\nNow we return to the original intent of this post. We want to show that the data is synced\nbetween a custom element instantiated with `PolymerView` and an unrelated Marionette view.\nWe will define two other Marionette views, one for displaying information about a person\n(basically like the name tag) and one for updating the person's name and job. We will\nalso define a Marionette layout for organizing our views. Our views and their templates\nare below:\n\nviews-1.jslinkvar Layout = Marionette.LayoutView.extend(&#x7b;\n  el: '#main',\n  template: '#layout-template',\n   regions: &#x7b;\n    nameTag: '#name-tag-container',\n    personView: '#person-view-container',\n    personForm: '#person-form-container'\n  &#x7d;\n&#x7d;);\n var NameTag = Marionette.PolymerView.extend(&#x7b;\n  tagName: 'name-tag'\n&#x7d;);\n var PersonFormView = Marionette.ItemView.extend(&#x7b;\n  template: '#person-form-template',\n   ui: &#x7b;\n    name: 'input[name=name]',\n    job: 'input[name=job]'\n  &#x7d;,\n   modelEvents: &#x7b;\n    'change': 'updateUI'\n  &#x7d;,\n   events: &#x7b;\n    'keyup input': 'updateModel'\n  &#x7d;,\n   updateUI: function() &#x7b;\n    var ui = this.ui;\n    var changed = this.model.changed;\n     _.each(changed, function(value, key) &#x7b;\n      if (ui[key].val() != value) &#x7b;\n        ui[key].val(value);\n      &#x7d;\n    &#x7d;);\n  &#x7d;,\n   updateModel: function(e) &#x7b;\n    var key = e.target.name;\n    var value = e.target.value;\n    this.model.set(key, value);\n  &#x7d;\n&#x7d;);\n var PersonView = Marionette.ItemView.extend(&#x7b;\n  template: '#person-view-template',\n   modelEvents: &#x7b;\n    change: 'render'\n  &#x7d;\n&#x7d;);\n\ntemplates-1.htmllink&lt;script id=\"layout-template\" type=\"text/html\"&gt;\n  &lt;div class=\"column\"&gt;\n    &lt;h2&gt;Name Tag PolymerView&lt;/h2&gt;\n    &lt;div id=\"name-tag-container\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"column\"&gt;\n    &lt;h2&gt;Person View&lt;/h2&gt;\n    &lt;div id=\"person-view-container\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"column\"&gt;\n    &lt;h2&gt;Person Form View&lt;/h2&gt;\n    &lt;div id=\"person-form-container\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/script&gt;\n &lt;script id=\"person-view-template\" type=\"text/html\"&gt;\n  &lt;h2&gt;Person View&lt;/h2&gt;\n  &lt;h3&gt;Name: &lt;%= name %&gt;&lt;/h3&gt;\n  &lt;h3&gt;Job: &lt;%= job %&gt;&lt;/h3&gt;\n&lt;/script&gt;\n &lt;script id=\"person-form-template\" type=\"text/html\"&gt;\n  &lt;div&gt;Name: &lt;input type=\"text\" name=\"name\" value=\"&lt;%= name %&gt;\"&gt;&lt;/div&gt;\n  &lt;div&gt;Job: &lt;input type=\"text\" name=\"job\" value=\"&lt;%= job %&gt;\"&gt;&lt;/div&gt;\n&lt;/script&gt;\n\nNotice in our `views-1.js` that we again define a `NameTag` view from `PolymerView`. We\nalso define a `PersonFormView` for editing the person model data and a `PersonView` for\njust displaying the person model data. Finally, we wire it all up:\n\nname-tag-usage-marionette-2.jslinkvar Person = Backbone.Model.extend();\n var person = new Person(&#x7b;\n  name: 'Jeremy Fairbank',\n  job: 'Web Developer'\n&#x7d;);\n var nameTag = new NameTag(&#x7b;\n  model: person\n&#x7d;);\n var personView = new PersonView(&#x7b;\n  model: person\n&#x7d;);\n var personFormView = new PersonFormView(&#x7b;\n  model: person\n&#x7d;);\n var layout = new Layout();\nlayout.render();\n layout.getRegion('nameTag').show(nameTag);\nlayout.getRegion('personView').show(personView);\nlayout.getRegion('personForm').show(personFormView);\n\nDEMO\n\n(Again, the demo may not work on mobile devices.) Try editing the name and job in both\nthe `PolymerView` section and the `PersonFormView` section. You will see the name and job\nupdate for the other views regardless of where you update the data!\n\n## Conclusion\n\nI know this is not anything groundbreaking. I do not doubt that someone has already done this.\nRegardless, I think it shows the exciting possibilities of combining web technologies and\nopens the door to incorporating web components into JavaScript applications already built\non existing frameworks. I hope this post ignites your curiosity and propels you\nto play around with web components and join the big ole' JavaScript playground that we\nlove to have fun in from time to time.\n\nIf you have any trouble with the demo or ideas to improve this implementation, please\nlet me know in the comments or make a pull request at the GitHub repo.\n\n**Notes:**\n\\* If you are a JavaScript developer, I encourage you to support, talk at, and attend\nNodevember. The organizers did a fantastic job putting it together,\nand the caliber of speakers was spectacular.\n\n",
          "link": "http://blog.jeremyfairbank.com/javascript/polymer-web-components-with-marionette-js/",
          "date": "2015-01-03 00:00:00 -0500",
          "excerpt": ""
        }
        
      
    
      
        ,{
          "title": "Open Source You",
          "content": "\n  \n    Contents\n  \n\n\n  On Knowledge and Experience\n  On Community\n  On Your Time\n  Happy New Year, Open Source You    \n      Additional Info\n    \n  \n\n\n  \n\n\n\nThe past several months have been an exciting and stressful time for me. My wife gave birth to our first child, I\nstarted a new job, I started an online Master’s program, and I gave my first talk at a conference. Naturally, I needed\nto take a break from writing to focus on more important parts of my life. Now that I am through the first semester of\nmy online program, I have free time again to focus on writing and contributing to open source projects.\n\nIn this post, I would like to explore an idea that first struck me back in the summer. I was assisting others in\n/r/learnjavascript when a simple truth about\nswitch statements eluded me: do they use case equality === in\nconditional checks? …Really? I have used JavaScript for six years, built single-page apps, know closures and this\nlike the back of my hand, and for a split second I could not remember a critical part of a control flow structure.\nQuickly reminding myself of case equality, I was able to easily answer the other person’s question. However, this\noccurrence deeply affected me, leading to this tweet:\n\nGive back and educate. Forces you to really understand what you claim to know and challenges your currently accepted ideas. #programming&mdash; Jeremy Fairbank (@ElPapaPollo) June 28, 2014\n\n\nThis idea has stirred in my mind since that tweet, and speaking at and attending the recent\nNodevember conference gave me the impetus to finally expound upon it. I feel that this\nconcept transcends more than just sharing what you know and is about building an accountable and edifying community.\nWe all have unique perspectives and experiences to share, and we can all learn from one another and our own\ntransparency. Given our industry, I think that it is appropriate to view this as making yourself open source to the\nrest of the community. I hope this post serves as an encouragement to everyone in our field and opens the door for\nevery voice, regardless of seniority or gender, to be heard.\n\nOn Knowledge and Experience\n\nDo you realize that you know some cool stuff? You are a programmer and can affect electrons in amazing ways! It does\nnot matter what your seniority level is; you already have a repertoire of knowledge and experience from which you can\ncreate fascinating programs and tools. Do not kid yourself!\n\nAnd yes, you know so little. I always feel disheartened when a junior developer laments knowing so little and stands\nin awe at the level of knowledge possessed by senior developers. Sometimes the biggest kept secret is that we all know\nso little! We have all barely scratched the surface. There are new programming languages, new frameworks, and new\napproaches to problems and algorithms. We will never grasp it all, but we grow each day.\n\nHow do we grow? Through an open community that is constantly willing to share new discoveries and share help without\njudgment. We are all just making pull requests against the biggest repo of programming knowledge. So, start making\nsome pull requests. I guarantee you that someone does not know what you do. And vice versa. How will anyone ever learn\nif no one ever shares his/her knowledge? Sharing what you know may be the final piece someone needs to reduce a\nproblem to a simpler implementation.\n\nEven if you do not have the exact knowledge or experience for a particular problem, I am sure you have an opinion or\nan idea on how to solve it. Share it. Solving programming problems usually starts with a simple plan that does not\ndepend upon the details of which language or technology. We developers tend to take a tunnel vision approach to\nprogramming. When we think of one approach, we typically stick with it, but another set of eyes might be the fresh\nperspective to provide a better solution. This type of collaboration is imperative, especially for open source\nprojects!\n\n\n\n\n\nOn Community\n\nAs we become transparent about our knowledge and ideas, we need to be open and supportive of one another. Yes, that\njunior developer’s idea might be absolutely terrible or someone’s excitement over learning HTML might seem silly.\nDo NOT treat that person flippantly or beneath you. If someone has a bad idea, then patiently show and help\nhim/her understand a better way. Congratulate and encourage new learners. You were there once. The last thing we need to\ndo is discourage others from cultivating a love and passion for computer science. They could be the ones to create\nnew algorithms, frameworks, or languages that push forward our field.\n\n\n  \n\n\nOver the past several months, I am sure almost everyone has seen the graph above. I think this resonates deeply with\nthe issue of a closed-off community. I do not doubt that several factors are at play with the decline of women in\ncomputer science, but we cannot deny that the most significant portion of the problem is rooted in sexism in our field\n(whether from colleagues or advertising).\n\nWhy are we harassing and discouraging women in tech? Have we forgotten our history? Many of the first programmers were\nwomen! The programming language Ada was named after Ada Lovelace, arguably the first computer programmer. She\nenvisioned the potential of computers back in the mid-19th century. Many women helped program the first computer to\naid in ballistic calculations during World War II. Grace Hopper, a remarkable woman in several rights, created the\nfirst compiler and is credited with coining the term “debugging.”\n\nThere is a lot to be said on the topic of women in tech, but I do not have the objective data to back up all my claims\nor the time to give this topic a proper treatment in light of the overall theme of this post.  (However, please do not\nmisinterpret my lack of detail as a flippant treatment of the topic.) Suffice it to say this is a serious issue and\nindicative of closed-source communities. Obviously not everyone in the community is misogynist and exclusive, but there\nis no denying this problem still exists. Being open-source is not only sharing your ideas but considering others’ ideas.\nTherefore, open your mind and allow your ideas and perspective to be challenged by other people. Give them space to explore\nand change the world with you.\n\nOn Your Time\n\nIn light of the topics I have briefly explored, I feel that to become “open source” we must open source our time. We cannot\nbegin to share our knowledge and build an edifying community if we do not offer up our time. Join a local user group,\nstart a blog, give a talk, or volunteer at a coding camp for kids. Such altruistic endeavors have no doubt helped form\nmany great programmers and helped build a vibrant programming community.\n\nCoincidentally, you will find that your own knowledge will grow throughout your efforts. Countless times when I have\nexplained a concept, framework, or language feature to someone else, I discovered that my own understanding of it expanded.\nIf someone has inquired about something I only understood at face value, then I have been forced to dig deeper, so\nI can better explain it to him/her.\n\nHappy New Year, Open Source You\n\nSo, start the new year open sourcing yourself. You owe it to the community and yourself. I promise you will not regret it.\n\nAdditional Info\n\nIf this topic deeply interests you, I encourage you to share your own experiences or ideas in the comments. Here are\na few articles that I found useful in formulating my ideas:\n\n\n  Egoless Programming: You Are Not Your Job\n  The Ten Commandments of Egoless Programming\n  When Women Stopped Coding\n  Technology’s Man Problem\n  Women in computing\n\n",
          "link": "http://blog.jeremyfairbank.com/programming/open-source-you/",
          "date": "2014-12-31 00:00:00 -0500",
          "excerpt": ""
        }
        
      
    
      
        ,{
          "title": "Components with Backbone.js and Marionette.js",
          "content": "\n  \n    Contents\n  \n\n\n  Building and Maintaining Applications with Components\n  Framework Components\n  Modularity and Components in Marionette\n  Components Are Reusable\n  Create A Component Type\n  Conclusion\n\n\n  \n\n\n\nA lot of my JavaScript work involves using Backbone.js and Marionette.js for the front-end. I really like other frameworks such as Angular.js too. Despite the framework I find myself in, I immediately gravitate toward whatever modular patterns that framework facilitates. More specifically, I am interested in how I can build reusable components within the framework. Components are the objects that encapsulate some specific functionality and typically operate independently of the application as a whole. For example, imagine the cliché stock widget that displays stock symbols along with their current prices. It functions entirely on its own, but together with other components it makes up a dashboard page.\n\nBuilding and Maintaining Applications with Components\nComponents are critical to scaleable applications because they encourage separation of concerns. Each piece of an application, including components, should have one responsibility and not heavily depend on the other pieces. Applications with tightly coupled modules or a lack of division of work will become incredibly more difficult to maintain and amend with newer features. Adding a single feature could require changing code in several places. Altering a function here breaks a function there, which then requires this other function to handle another parameter. Discovering everything that breaks usually involves a trial-and-error process of integration tests with your eyeballs. Suddenly, you’re traveling down the recursive Twilight Zone of refactoring ad nauseam and other smart-people Latin phrases.\n\nComponents also encourage the DRY principle. In case you don’t know, the DRY principle stands for “Don’t Repeat Yourself.” You will waste extra time in the long run if you repeatedly write the same code, especially when you need to go back to refactor or add another feature. If you need to build a few datagrids with the same style but different data, then you should abstract that out into a reusable datagrid component. Then, all you need to do is configure each instance of the datagrid with its data. Components GOOD, monolithic applications BAD.\n\nFramework Components\nNow, for the purpose of this article, we should have a shared idea of what a component is. I’ve already hinted at my understanding of a component. A component is akin to a sub-application, with its own views, models, state, business logic, and even sub-components. When it comes to JavaScript frameworks, Angular overtly offers components in the form of directives. Directives allow you to create custom HTML elements via a handful of syntactical options. You may also define a controller and scope for the directive to handle related business logic and state, respectively. The beauty of directives is how easily reusable they are. Define your own HTML element and then just plop it into your application views where you need it. You can even use them inside other directives in a way that would make Xzibit proud (fine, old joke, shame on me).\n\nHowever, when it comes to Backbone.js, we don’t necessarily have our go-to object to handle components. Yes, we have views which are reusable, but we would need to add several methods to a view to make it like a component. You would need both business logic and the boilerplate code to facilitate adding and removing to the DOM (without creating memory leaks). If you try to do this all with a single view, I’m fairly certain you’ll violate the single responsibilty principle.\n\nWell, this leaves us with rolling our own solution, which isn’t a terrible idea. I advocate trying it out yourself and stretching your current understanding and abilities. However, countless other people have faced a similar issue, and someone has probably already built a robust solution that solves the problem.\n\nModularity and Components in Marionette\n\nIn steps Marionette.js. Marionette is an awesome library created by Derick Bailey to eliminate a host of the pains associated with building applications in vanilla Backbone. It offers a sensible boilerplate that supplies several view types, an application router, modules, an event aggregator, and many other objects. In my opinion, the greatest benefit of Marionette is that it empowers you to easily build modular Backbone applications.\n\nAs previously stated, Marionette offers modules, which are our go-to objects for segregating the different pieces of our application. They almost sound like components, but there is still a distinction. Modules operate as sub-applications and namespaces that separate the different concerns of our application. A music streaming application may have an account module for handling user account information and an albums module for displaying and filtering albums to listen to. Within the account module, we would have a component for updating billing information and another component for updating the email address and password.\n\nHowever, we can use modules to act as components in Marionette. Let’s walk through building a datagrid component for an orders dashboard page. (If you’re unfamiliar with Marionette’s objects and syntax, I encourage you to look at the docs on the GitHub repo marionettejs/backbone.marionette first.)\n\napp.jsvar MyApp = new Marionette.Application();\n // Helper for switching modules, or sub apps\nMyApp.startSubApp = function(subApp) &#x7b;\n  var currentApp = MyApp.module(subApp);\n   if (MyApp.currentApp === currentApp) &#x7b;\n    return;\n  &#x7d;\n   if (MyApp.currentApp) &#x7b;\n    MyApp.currentApp.stop();\n  &#x7d;\n   App.currentApp = currentApp;\n   currentApp.start();\n&#x7d;;\n MyApp.addRegions(&#x7b;\n  mainRegion: '#main'\n&#x7d;);\n MyApp.on('start', function() &#x7b;\n  Backbone.history.start();\n&#x7d;);\n\nHere we set up our base application called MyApp, attach an existing HTML element with id #main to the app’s mainRegion, and listen for the app’s start event to make sure Backbone history is running. We also add a simple helper method startSubApp for managing the currently running sub-application, or module.\n\norders/orders.js// Define our orders module\nMyApp.module('Orders', function(Orders, MyApp, Backbone, Marionette, $, _) &#x7b;\n   // Router\n  Orders.Router = Marionette.AppRouter.extend(&#x7b;\n    appRoutes: &#x7b;\n      'orders/dashboard': 'ordersDashboard'\n    &#x7d;\n  &#x7d;);\n   // Controller\n  Orders.Controller = Marionette.Controller.extend(&#x7b;\n    ordersDashboard: function() &#x7b;\n      App.startSubApp('Orders.Dashboard');\n      Orders.Dashboard.controller.show();\n    &#x7d;\n  &#x7d;);\n   // Initializers\n  Orders.addInitializer(function() &#x7b;\n    Orders.controller = new Orders.Controller();\n     Orders.router = new Orders.Router(&#x7b;\n      controller: Orders.controller\n    &#x7d;);\n  &#x7d;);\n &#x7d;);\n\nThis is our main orders module. We define the module, a router, and a controller for orders-related functionality. We ensure everything is properly wired up with a call to addInitializer on the module as well. Notice in Orders.Controller#ordersDashboard we start up and show the Orders.Dashboard submodule, which we define below.\n\norders/dashboard/dashboard.js// Define our dashboard submodule\nMyApp.module('Orders.Dashboard', function(Dashboard, MyApp, Backbone, Marionette, $, _) &#x7b;\n   Dashboard.startWithParent = false;\n   // Model\n  Dashboard.DashboardOrders = Backbone.Model.extend(&#x7b;\n    defaults: &#x7b;\n      incompleteOrders: [],\n      submittedOrders: [],\n      shippedOrders: []\n    &#x7d;,\n     url: '/api/orders/dashboard'\n  &#x7d;);\n   // LayoutView\n  Dashboard.LayoutView = Marionette.LayoutView.extend(&#x7b;\n    template: '#orders-dashboard-layout-template',\n     regions: &#x7b;\n      incompleteOrders: '#incomplete-orders'\n    &#x7d;\n  &#x7d;);\n   // Controller\n  Dashboard.Controller = Marionette.Controller.extend(&#x7b;\n    initialize: function(options) &#x7b;\n      this.region = options.region;\n    &#x7d;,\n     show: function() &#x7b;\n      this.layout = this.getLayout();\n      this.region.show(this.layout);\n    &#x7d;,\n     getLayout: function() &#x7b;\n      var layout = new LayoutView();\n      this.listenTo(layout, 'show', this.showGrid);\n      return layout;\n    &#x7d;,\n     showGrid: function() &#x7b;\n      var dashboardOrders = new Dashboard.DashboardOrders();\n       dashboardOrders.fetch().\n        then(this._showGridComponent(\n          this.layout.incompleteOrders,\n          dashboardOrders.incompleteOrders\n        ));\n    &#x7d;,\n     onDestroy: function() &#x7b;\n      Dashboard.DataGrid.stop();\n    &#x7d;,\n     _showGridComponent: function(region, dashboardOrders) &#x7b;\n      return function() &#x7b;\n        Dashboard.DataGrid.start(&#x7b;\n          collection: dashboardOrders.incompleteOrders,\n          region: region\n        &#x7d;);\n         Dashboard.DataGrid.controller.show();\n      &#x7d;;\n    &#x7d;\n  &#x7d;);\n   // Initializers\n  Dashboard.addInitializer(function(options) &#x7b;\n    Dashboard.controller = new Dashboard.Controller(&#x7b;\n      region: MyApp.mainRegion\n    &#x7d;);\n     Dashboard.controller.show();\n  &#x7d;);\n   // Finalizers\n  Dashboard.addFinalizer(function() &#x7b;\n    Dashboard.controller.destroy();\n    delete Dashboard.controller;\n  &#x7d;);\n &#x7d;);\n\nThis is our Dashboard submodule. Notice we set Dashboard.startWithParent = false. This prevents the module from automatically running because we will want it to start only when we need it. In the controller after we show the layout, we fetch the dashboard orders and display the incomplete orders in a datagrid component via showGrid and _showGridComponent. If our module is stopped, we make sure to also stop the datagrid component in onDestroy.\n\norders/dashboard/dataGrid.js// Define our datagrid module component\nMyApp.module('Orders.Dashboard.DataGrid', function(DataGrid, MyApp, Backbone, Marionette, $, _) &#x7b;\n   DataGrid.startWithParent = false;\n   // Views\n  DataGrid.RowView = Marionette.ItemView.extend(&#x7b;\n    template: '#orders-dashboard-datagrid-row-template',\n    tagName: 'tr'\n  &#x7d;);\n   DataGrid.GridView = Marionette.CompositeView.extend(&#x7b;\n    template: '#orders-dashboard-datagrid-template',\n    childView: DataGrid.RowView,\n    childViewContainer: 'tbody'\n  &#x7d;);\n   // Controller\n  DataGrid.Controller = Marionette.Controller.extend(&#x7b;\n    initialize: function(options) &#x7b;\n      this.region     = options.region;\n      this.collection = options.collection;\n    &#x7d;,\n     show: function() &#x7b;\n      this.gridView = this.getGridView();\n      this.region.show(this.gridView);\n    &#x7d;,\n     getGridView: function() &#x7b;\n      var gridView = new DataGrid.GridView(&#x7b;\n        collection: this.collection\n      &#x7d;);\n       this.listenTo(gridView, 'foo', this.doBar);\n       return gridView;\n    &#x7d;,\n     doBar: function() &#x7b;\n      console.log('I did bar!');\n    &#x7d;\n  &#x7d;);\n   // Initializers\n  DataGrid.addInitializer(function(options) &#x7b;\n    DataGrid.controller = new DataGrid.Controller(&#x7b;\n      region: options.region,\n      collection: options.collection\n    &#x7d;);\n  &#x7d;);\n   // Finalizers\n  DataGrid.addFinalizer(function() &#x7b;\n    DataGrid.controller.destroy();\n    delete DataGrid.controller;\n  &#x7d;);\n &#x7d;);\n\nThis is our DataGrid module component. Notice, we’ve set it up similar to the Dashboard module. We can instantiate our component and use it with DataGrid.start followed by DataGrid.controller.show.\n\nview&lt;script id=\"orders-dashboard-layout-template\" type=\"text/html\"&gt;\n  &lt;h1&gt;Orders Dashboard&lt;/h1&gt;\n  &lt;div id=\"incomplete-orders\"&gt;&lt;/div&gt;\n&lt;/script&gt;\n &lt;script id=\"orders-dashboard-datagrid-row-template\" type=\"text/html\"&gt;\n  &lt;td&gt;&lt;%= id %&gt;&lt;/td&gt;\n  &lt;td&gt;&lt;%= total %&gt;&lt;/td&gt;\n&lt;/script&gt;\n &lt;script id=\"orders-dashboard-datagrid-template\" type=\"text/html\"&gt;\n  &lt;table&gt;\n    &lt;thead&gt;\n      &lt;tr&gt;\n        &lt;th&gt;ID&lt;/th&gt;\n        &lt;th&gt;Total&lt;/th&gt;\n      &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;&lt;/tbody&gt;\n  &lt;/table&gt;\n&lt;/script&gt;\n &lt;div id=\"main\"&gt;&lt;/div&gt;\n &lt;script src=\"app.js\"&gt;&lt;/script&gt;\n&lt;script src=\"orders/orders.js\"&gt;&lt;/script&gt;\n&lt;script src=\"orders/dashboard/dashboard.js\"&gt;&lt;/script&gt;\n&lt;script src=\"orders/dashboard/dataGrid.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  MyApp.start();\n&lt;/script&gt;\n\nFinally, our HTML view.\n\nComponents Are Reusable\n\nSo, the datagrid module works almost perfectly as a component. It has its own logic, state, and view, but something isn’t right. Remember components are reusable. If we set up a datagrid component using a module and then want to use it multiple times, we would encounter a problem. We’re locked down to one instance of the component at any one time by the controller property set in the addInitializer call. We need to tweak our module to allow for multiple instances.\n\norders/dashboard/dataGrid.jsMyApp.module('Orders.Dashboard.DataGrid', function(DataGrid, MyApp, Backbone, Marionette, $, _) &#x7b;\n   // Let it start with parent now. This is usually the default for modules, but\n  // I'm explicity setting it to true this time to show the difference with our\n  // earlier version of this module.\n  DataGrid.startWithParent = true;\n   // Definitions for views and controller go here...\n   // This time DON'T define initializers or finalizers. Instead we want to\n  // create an interface for instantiating multiple component instances.\n   DataGrid.newComponent = function(options) &#x7b;\n    return new DataGrid.Controller(&#x7b;\n      region: options.region,\n      collection: options.collection\n    &#x7d;);\n  &#x7d;;\n &#x7d;);\n\nBefore, we depended on DataGrid.start to create a single instance of the component. Now, we have an interface for creating multiple component instances via our DataGrid.newComponent method. Therefore, we redefine our component module to automatically start with its parent, and we remove initializers and finalizers because we don’t have to depend on start to use our component.\n\norders/dashboard/dashboard.jsMyApp.module('Orders.Dashboard', function(Dashboard, MyApp, Backbone, Marionette, $, _) &#x7b;\n   // Earlier definitions...\n   // LayoutView\n  Dashboard.LayoutView = Marionette.LayoutView.extend(&#x7b;\n    template: '#orders-dashboard-layout-template',\n     regions: &#x7b;\n      incompleteOrders: '#incomplete-orders',\n      submittedOrders: '#submitted-orders',\n      shippedOrders: '#shipped-orders'\n    &#x7d;\n  &#x7d;);\n   // Controller\n  Dashboard.Controller = Marionette.Controller.extend(&#x7b;\n    initialize: function(options) &#x7b;\n      this.region = options.region;\n    &#x7d;,\n     show: function() &#x7b;\n      this.layout = this.getLayout();\n      this.region.show(this.layout);\n    &#x7d;,\n     getLayout: function() &#x7b;\n      var layout = new LayoutView(&#x7b;\n        model: this.model\n      &#x7d;);\n       this.listenTo(layout, 'show', this.showGrids);\n       return layout;\n    &#x7d;,\n     showGrids: function() &#x7b;\n      var dashboardOrders = new Dashboard.DashboardOrders();\n      dashboardOrders.fetch().then(this._showGridComponents(dashboardOrders));\n    &#x7d;,\n     onDestroy: function() &#x7b;\n      _.each(this._grids, function(grid) &#x7b;\n        grid.destroy();\n      &#x7d;);\n       delete this._grids;\n    &#x7d;,\n     _showGridComponents: function(dashboardOrders) &#x7b;\n      var self = this;\n      var layout = this.layout;\n       return function() &#x7b;\n        self._showGridComponent(layout.incompleteOrders, dashboardOrders.incompleteOrders);\n        self._showGridComponent(layout.submittedOrders, dashboardOrders.submittedOrders);\n        self._showGridComponent(layout.shippedOrders, dashboardOrders.shippedOrders);\n      &#x7d;;\n    &#x7d;,\n     _showGridComponent: function(region, orders) &#x7b;\n      if (!this._grids) &#x7b;\n        this._grids = [];\n      &#x7d;\n       var datagrid = Dashboard.DataGrid.newComponent(&#x7b;\n        collection: orders,\n        region: region\n      &#x7d;);\n       this._grids.push(datagrid);\n       datagrid.show();\n    &#x7d;\n  &#x7d;);\n   // Define initializers and finalizers...\n &#x7d;);\n\nhtml&lt;!-- Add our other regions --&gt;\n&lt;script id=\"orders-dashboard-layout-template\" type=\"text/html\"&gt;\n  &lt;h1&gt;Orders Dashboard&lt;/h1&gt;\n  &lt;div id=\"incomplete-orders\"&gt;&lt;/div&gt;\n  &lt;div id=\"submitted-orders\"&gt;&lt;/div&gt;\n  &lt;div id=\"shipped-orders\"&gt;&lt;/div&gt;\n&lt;/script&gt;\n\nOK, now we have a component that is reusable. We instantiate our datagrid three times to display different categories of orders on our dashboard page. This seems to work well, but we can’t deny the little bit of code smell.\n\nCreate A Component Type\n\nIf we want to create more components in our application, we will have to repeat the same pattern of creating a new module and setting the newComponent method on it. We don’t want to manually add the method to every module component. Yes, we could create a custom module with that method defined on its prototype and then let our module components inherit from it. But, that still doesn’t address the issue of using modules for something they’re not. All we’ve done is use a module as a glorified wrapper for other objects. In fact, our datagrid is really just two views and a controller. If all we really need to do is wrap other objects, then we should create a custom component type to use as our facade.\n\nlib/marionette.component.jsMarionette.Application.prototype.component =\nMarionette.Module.prototype.component = function(name, options) &#x7b;\n  var Component = this[name];\n   if (!Component) &#x7b;\n    Component = Marionette.Component.extend(options);\n    this[name] = Component;\n  &#x7d;\n   return Component;\n&#x7d;;\n Marionette.Component = Marionette.Controller.extend(&#x7b;\n  constructor: function(options) &#x7b;\n    options = options || &#x7b;&#x7d;;\n     this.region     = options.region;\n    this.model      = options.model;\n    this.collection = options.collection;\n     Marionette.Controller.prototype.constructor.apply(this, arguments);\n  &#x7d;,\n   show: function() &#x7b;\n    this.showView();\n  &#x7d;,\n   showView: function() &#x7b;\n    var view = this.view = this.getView();\n     this.listenTo(view, 'show', function() &#x7b;\n      this.triggerMethod('show:view');\n    &#x7d;);\n     this.region.show(view);\n  &#x7d;\n&#x7d;);\n Marionette.Component.define = function(options) &#x7b;\n  _.extend(this.prototype, options);\n&#x7d;;\n\nSo, we’ve defined a new type: Marionette.Component. This component type is based off work Derick Bailey did when he and I developed together on a project. To actually create or use a component, we call component on an instance of a Marionette application or module. It attaches the component to the receiver and takes in options to add to the component prototype. We can also call define on our component type to add other properties to the prototype.\n\nNotice the component type makes some assumptions about how it will be used. It takes a region for displaying itself along with a model and/or a collection. It has a show method, where it calls showView. Notice that showView calls getView but doesn’t define it. When you create your own custom component type through this interface, you need to supply a getView method that returns your custom view instance (item view, collection view, layout view, etc.).\n\nThe component also listens for the show event on the view and triggers an onShowView method via the this.triggerMethod('show:view') call. So, you can also define an onShowView method if you need to do additional work after the view is displayed. Finally, the component displays the view in the supplied region.\n\nLet’s use our new component type to redefine our datagrid component.\n\norders/dashboard/dataGrid.js// Define the component under the dashboard module now\nMyApp.module('Orders.Dashboard', function(Dashboard, MyApp, Backbone, Marionette, $, _) &#x7b;\n   // Instead of a controller, use our module `component` method\n  var DataGrid = Dashboard.component('DataGrid');\n   // Views stay the same from the previous version...\n   // Define the actual component type\n  DataGrid.define(&#x7b;\n    getView: function() &#x7b;\n      var gridView = new DataGrid.GridView(&#x7b;\n        collection: this.collection\n      &#x7d;);\n       this.listenTo(gridView, 'foo', this.doBar);\n       return gridView;\n    &#x7d;,\n     doBar: function() &#x7b;\n      console.log('I did bar!');\n    &#x7d;\n  &#x7d;);\n &#x7d;);\n\nNotice that we still define the component within a module, but we’re just reopening up our dashboard module to create the datagrid component on it. We still define the views in the same way, and then we define the datagrid type. Since we made assumptions about how components should be used (for example, take some basic options in their constructor and provide a show method), all we need to define is our getView method and any other custom logic we require.\n\norders/dashboard/dashboard.jsMyApp.module('Orders.Dashboard', function(Dashboard, MyApp, Backbone, Marionette, $, _) &#x7b;\n   // Earlier definitions...\n   // Redefine our controller method for showing a grid\n  Dashboard.Controller = Marionette.Controller.extend(&#x7b;\n    // Earlier method definitions...\n     _showGridComponent: function(region, order) &#x7b;\n      if (!this._grids) &#x7b;\n        this._grids = [];\n      &#x7d;\n       var datagrid = new Dashboard.DataGrid(&#x7b;\n        collection: orders,\n        region: region\n      &#x7d;);\n       this._grids.push(datagrid);\n       datagrid.show();\n    &#x7d;\n  &#x7d;);\n   // Define initializers and finalizers...\n &#x7d;);\n\nWe make sure to update our dashboard controller to instantiate the datagrid components with the new component type constructor.\n\nscripts&lt;script src=\"app.js\"&gt;&lt;/script&gt;\n&lt;script src=\"lib/marionette.component.js\"&gt;&lt;/script&gt;\n&lt;script src=\"orders/orders.js\"&gt;&lt;/script&gt;\n&lt;script src=\"orders/dashboard/dashboard.js\"&gt;&lt;/script&gt;\n&lt;script src=\"orders/dashboard/dataGrid.js\"&gt;&lt;/script&gt;\n\nFinally, we add the component source file to our loaded scripts.\n\nConclusion\n\nSo, we now understand how to build reusable components in Backbone.js and Marionette.js. We’ve learned that components allow us to reduce the amount of code we need to write and afford us more scaleable applications. I think this simple approach to components in Marionette can go a long way toward building modular applications. I’m sure there are ways to improve our component type and reduce even more repeated patterns. I know our method of defining and using modules could use some refactoring, possibly incorporating some of the same ideas we used to make our custom component type.\n\nI hope you enjoyed this post, and I look forward to any questions or feedback!\n",
          "link": "http://blog.jeremyfairbank.com/javascript/components-with-backbone-js-and-marionette-js/",
          "date": "2014-06-25 00:00:00 -0400",
          "excerpt": ""
        }
        
      
    
      
        ,{
          "title": "First Post: Ensuring Remote Data is Available in JavaScript",
          "content": "\n  \n    Contents\n  \n\n\n  Greetings\n  The Problem\n  The Solution\n  Conclusion\n\n\n  \n\n\n\nGreetings\n\nHello, my name is Jeremy Fairbank, and I am a front-end and back-end web developer.\n\nSo, I have wanted to do a development blog for a long time, but I become easily distracted by Reddit, video games, or that random programming question that has been racking my brain for the past few days, and I will not be able to sleep tonight unless I sit down at my computer to solve it… Whew. I admit I like to see instantaneous results from my work (that is probably why I am a programmer), so I simply cannot be bothered with all the minutiae of setting up a blog.\n\nHowever, I get frustrated when I have a stroke of brilliance, swooping in to save the day with an incredibly elegant solution to a programming problem, and really want to share that with someone. You see, I am the development team where I work, so I do not have the junior developer to teach or the senior developer to probe for feedback and criticism. Half of my solutions could be terrible, unmaintable wrecks just waiting to rear their ugly heads in production months later.\n\nDon’t get me wrong, I still read articles and books and follow many a twitterer, so I’m always learning the thing I did last week was really stupid. OK, maybe not stupid, but definitely not as scaleable or maintainable as it could be. Ultimately, I LOVE to talk about programming, just ask my wife. I really want to be able to share my thoughts and opinions and garner feedback from fellow developers.\n\nTherefore, what better way than to finally start my blog and jump right in with an interesting fix I implemented last week for a feature spec!\n\nThe Problem\n\nI can’t really share the specific domain models used, so I will use some suitable substitutes for the problem.\n\nWe have a large single-page application for ordering a highly customizable product. This application is built upon Backbone and Marionette with a Ruby on Rails back-end. Now, let’s say our configurable product is a car. Certain configuration options on the car will incur various upcharges. These upcharges will not change often, so they will be constant throughout a user’s session on the application. Thus, one of the JavaScript files pulls down all the possible upcharge types from an API on the back-end.\n\ncar.jsvar Car = Backbone.Model.extend();\n // car/upcharges.js\n var Upcharge = Backbone.Model.extend();\n var Upcharges = Backbone.Collection.extend(&#x7b;\n  model: Upcharge,\n  url: '/api/upcharges'\n&#x7d;);\n var availableUpcharges = new Upcharges();\navailableUpcharges.fetch();\n\nSo, car/upcharges.js immediately fetches the upcharges as soon as the browser loads the file. In a normal user session, this is completely acceptable because by the time the user can begin to use the application, the upcharges have loaded.\n\nAs the user navigates throughout the application, he/she will eventually make decisions that may require the application to add or remove different upcharges to a car. To handle this, the application uses another collection for managing which upcharges have been applied to the car based on a key field for each upcharge. Canonical upcharges have been seeded into the application with constant key names. For example, if the user wanted chrome rims, the application would add an upcharge via:\n\napp/some/module.jscar.appliedUpcharges.addUpchargeByKey('chrome_rims');\n\nThe collection for applied upcharges might look something like this then:\n\ncar/upcharges.jsvar Upcharges = Backbone.Collection.extend(&#x7b;\n  // earlier definitions...\n   getByKey: function(key) &#x7b;\n    return this.findWhere(&#x7b; key: key &#x7d;);\n  &#x7d;\n&#x7d;);\n var AppliedUpcharges = Backbone.Collection.extend(&#x7b;\n  model: Upcharge,\n   addUpchargeByKey: function(key) &#x7b;\n    return this._getUpchargeByKeyAndRun(key, this.addUpcharge);\n  &#x7d;,\n   removeUpchargeByKey: function(key) &#x7b;\n    return this._getUpchargeByKeyAndRun(key, this.removeUpcharge);\n  &#x7d;,\n   addUpcharge: function(upcharge) &#x7b;\n    if (!this.has(upcharge)) &#x7b;\n      return this.add(upcharge.clone());\n    &#x7d;\n  &#x7d;,\n   removeUpcharge: function(upcharge) &#x7b;\n    return this.remove(upcharge);\n  &#x7d;,\n   _getUpchargeByKeyAndRun: function(key, callback) &#x7b;\n    var upcharge = availableUpcharges.getByKey(key);\n    callback.call(this, upcharge);\n  &#x7d;\n&#x7d;);\n\nOK, so this is all fine and dandy and it works. Ehh, maybe we should move the logic for adding and removing upcharges to the back-end, but that’s for another time and place to discuss. In fact, I’m more in favor of that idea, but it would defeat the purpose of this blog post.\n\nNow, it’s time to set up a feature spec because we want to make sure that the upcharges display on the order totals page. Given we use RSpec, Capybara, and FactoryGirl, a very simplified version of the feature spec might look something like this:\n\ncar_spec.rbrequire 'spec_helper'\nrequire 'features/helpers'\n feature 'Configuring a car', js: true do\n  given(:user)  &#x7b; create(:user) &#x7d;\n  given(:order) &#x7b; create(:order, :incomplete) &#x7d;\n   background do\n    login_as user # Helper method from 'features/helpers'\n     create(:upcharge, &#x7b;\n      key: 'chrome_rims',\n      description: 'Chrome Rims',\n      price: 1000\n    &#x7d;)\n     car = create(:car)\n     order.car = car\n    order.save\n  end\n   scenario 'Viewing the order totals page' do\n    click_on 'Orders'\n     within('#orders-table') do\n      click_on \"Order ##&#x7b;order.id&#x7d;\"\n    end\n     click_on 'Configure Car'\n    click_on 'Add Chrome Rims'\n    click_on 'Order Totals'\n     totals = find('#order-totals')\n    expect(totals).to have_selector('.car-upcharge', count: 1)\n    expect(totals).to have_selector('.car-upcharge', text: 'Chrome Rims')\n  end\nend\n\nSo, I run the spec and it fails. Okay… Did I not properly set up the order and car? Is there some random attribute that is still nil on a model that needs to have a value? After strategically (maybe a little randomly) placing console.log’s and puts’s, I discovered that my availableUpcharges variable was an empty collection. But, I added the chrome rims upcharge in my background block.\n\nA couple more console.log’s and it begins to make sense. RSpec and Capybara load my application’s assets before the background block runs. So, I fetch the available upcharges before any have even been created. This is problematic for a single page application that pulls remote data down once to use it for the remainder of the user’s session. Yes, it’s good to not create additional requests for remote data, but maybe immediately loading the data when the file loads isn’t a good idea either.\n\nThe Solution\nWhat can we do then? A better solution would be to asynchronously load and use the available upcharges the first time they’re needed. We could use a singleton object for managing the available upcharges like so:\n\ncar/upcharges.jsvar AppliedUpcharges = Backbone.Collection.extend(&#x7b;\n  // other definitions...\n   // Redefine this function\n  _getUpchargeByKeyAndRun: function(key, callback) &#x7b;\n    var self = this;\n     availableUpcharges.ensured(function(upcharges) &#x7b;\n      var upcharge = upcharges.getByKey(key);\n      callback.call(self, upcharge);\n    &#x7d;);\n  &#x7d;\n&#x7d;);\n var availableUpcharges = &#x7b;\n  ensured: function(firstCallback) &#x7b;\n    var self = this;\n    var upcharges = new Upcharges();\n     upcharges.fetch(&#x7b;\n      success: function() &#x7b;\n        self.ensured = function(callback) &#x7b;\n          callback(upcharges);\n        &#x7d;;\n         self.ensured(firstCallback);\n      &#x7d;\n    &#x7d;)\n  &#x7d;\n&#x7d;;\n\nNow, we just call availableUpcharges.ensured first, passing it a callback function. We create one interface for accessing the real available upcharges, whether they’re loaded yet or not. Our singleton object handles loading them the first time. Once they’re loaded, it redefines it’s ensured method to just simply pass the loaded upcharges to the callback.\n\nI test it out in my application, but then I start to see multiple requests for the available upcharges. That’s the exact opposite of what this is supposed to do. Then, I realize my error. You see, our application automatically checks for multiple upcharges based on measurement constraints. There are multiple configurable measurements that are interrelated. So, if a user’s car had an atypical length-to-width ratio, then the application catches that on the order totals page and applies an appropriate upcharge. That way, if the user left the application and came back later, the application can recheck the car and update the upcharges as needed. Now, imagine there are several more of those measurement checks occurring all at once, meaning the application would call addUpchargeByKey and removeUpchargeByKey several times, calling _getUpchargeByKeyAndRun several times.\n\nThis presents a problem; if the application calls _getUpchargeByKeyAndRun multiple consecutive times and the available upcharges haven’t loaded yet, then it is going to naturally create multiple requests for them because the ensured function has not been redefined yet. We need to tweak our singleton object to take this into account:\n\ncar/upcharges.jsvar availableUpcharges = &#x7b;\n  queue: [],\n   ensured: function(firstCallback) &#x7b;\n    this.queue.push(firstCallback);\n     if (this.request) &#x7b;\n      return;\n    &#x7d;\n     var self = this;\n    var upcharges = new Upcharges();\n     this.request = upcharges.fetch(&#x7b;\n      success: function() &#x7b;\n        var currentCallback = null;\n         self.ensured = function(callback) &#x7b;\n          callback(upcharges);\n        &#x7d;;\n         while (currentCallback = self.queue.shift()) &#x7b;\n          self.ensured(currentCallback);\n        &#x7d;\n         delete self.request;\n        delete self.queue;\n      &#x7d;\n    &#x7d;);\n  &#x7d;\n&#x7d;;\n\nSo, what’s the difference? Well, until the available upcharges are loaded and the ensured function is redefined, we simply queue up every callback passed in and check to see if a request has already been made. Once the upcharges load, we redefine the function as before. We also clear our queue, calling the new ensured function definition with each queued callback. I run through the application again, and now there is only one request, and all the upcharge checks work properly. I rerun my spec and get my glorious green dot!\n\nConclusion\n\nI like this solution, and it’s currently working fine in production and testing. Granted, the business logic for checking these upcharges should move to the back-end, but it’s one of those refactors that gets overshadowed by other bugs and features (I’m sure you know what I mean). Regardless, I feel this is a relatively good starting point for handling this problem. You can use this type of approach to lazily load data in JavaScript that you may not need immediately.\n\nI hope you enjoyed this post and please provide whatever questions or feedback you have!\n",
          "link": "http://blog.jeremyfairbank.com/javascript/first-post-ensuring-remote-data-is-available/",
          "date": "2014-06-21 00:00:00 -0400",
          "excerpt": ""
        }
        
      
    
  ]
})
